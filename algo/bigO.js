// Big-O - оценка сложности алгоритма, нотация биг О показывает как будет меняться произовдительность алгоритма в зависисмости от роста входящих данных

// ПРИ УВЕЛЕЧЕНИИ ОБЪЁМА ВХОДЯЩИХ ДАННЫХ

// 1. может увеличиться время
// 2. количество памяти используемое данным алгоритмом

// Big-O показывает скорость роста этих параметров 

// O(n) - линейная сложность, зависит от количества данных
function getSumOfArray(arr){
    let sum = 0;

    for(let i = 0; i < arr.length; i++){
        sum += arr[i];
    };

    return sum
};

// O(1) - константная сложность, то есть работает вне зависимости от кол-ва данных которое поступает
function getLastElem(arr){
        return arr[arr.length-1]
};

console.log(2**14)
// O(log n) - логорифмическая сложность
// пример: бинарный поиск, если при линейном поиске кол-во операций на 10000 элементов будет 10000
// а при бинарном всего 14

// O(n log n)
// пример: Merge Sort

// O(n**2) - квадратичная сложность, от двух вложенных циклов и следуюет квадрат
function getMultiplyList(n){
    for(let i = 1; i <= n; i++){
        for(let j = 1; j <= n; j++){
            console.log(`${i} * ${j} = ${i+j}`);
        };
    };
};

// при n = 10000, алгоритм выполнит 100 000 000 операций

// O(n**3) - кубическая сложность, три вложенных цикла соответсенно куб
// при n = 10000, алгоритм выполнит 100 000 000 000 000 операций

// O(2n) - экспонентальная сложность
function getFib(n){
    if(n < 2){
        return n;
    };
    return getFib(n-1) + getFib(n-2);
};

// O(n!) - отвратительная сложность, растет быстрее всех

// РАСЧЕТ СЛОЖНОСТИ
// существует не важная сложность к примеру когда есть отдельный цикл и два вложенных сложнлсть будет O(n + n**2)
// первую n можно просто отбросить тк будет выполнено 10000 операций а во втором случае 100 000 000

// отбрасываем мы в том случае когда у нас какая то сложность растет в разы медленнее чем другая