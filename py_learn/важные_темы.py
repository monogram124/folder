# КОНСПЕКТ С ВАЖНЫМИ ТЕМАМИ СВЯЗАННЫМИ С ЯЗЫКОМ И НЕ ТОЛЬКО

# *ARGS и **KWARGS и распаковка
# распаковка очень удобная вещь
a, b, c = 1, 2, 3 # интерпретатор по очереди назначит значения
a, b, c = "a, b, c" # так тоже назначит a = "a" и тд
a, b, c = [1, 2, 3] # и так тоже
# если сделаем вот так 
a, b = [1, 2, 3] # будет ошибка ValueError (expected 3, got 2)
# * - по сути значит все осталное
# то есть если напишу так:
a, *b = [1, 2, 3, 4] # a = 1, b = [2, 3, 4], b именно список
# можно использовать и вот так например
a, *b, c = [1, 2, 3, 4] # a = 1; b = [2, 3]; c = 4
# и то что новое это то что можно сделать вот так:
print(*[1, 2, 3]) # вернет просто 1 2 3, распакует достанет то есть и просто разместит как 1, 2, 3  
 
# аргумент в функцияз делаться на позиционные и ключевого слова
# позиционные передаем по порядку типо:
def func(a, b, /, c, *, d):
    print(a)
    print(b)
    print(c)

func(1, 2, 3) # передали позиационные
func(c=1, a=2, b=3) # ключегого слова
# func(a=1, 2, b=3) так вот нельзя, по скольку аргументы позиционные не могут идти после аргументов ключевого слова, можно вот так: func(1, b=2, c=3

# ! в функции мы можем отделить позиционные от остальных слешем (показал на func), то есть все что слева - позиционные все что справа можем передавать и то и то
# ! также можем отделить keyword от остальных звездчкой (показал на func), то есть все что СПРАВА - keyword аргументы

# из функции *args вернет кортеж args
# из функции **kwargs вернет словарь kwargs

def exmpl(*args, **kwargs):
    print(f"kwargs:{kwargs}")
    print(f"args:{args}")
    for arg in args:
        print(str(arg))

exmpl(1, 2, 3, 4, 5, number=2)

# при распаковке словаря ** происходит то что словарь ключ выноситься как аргумент, значение как значение то есть например если мы захотели с помощью кваргс передать sep=":" и end="-" в принт сделаем так
# print(1, 2, **{"sep"=":", "end"="-"}), то есть мы буквально убираем скобки фигурные и звездочки и получаем sep=":" и end="-"
# ===================================================== 

# КОМПИЛЯТОР/ИНТЕРПРЕТАТОР (опять же ничего нового просто чтобы не потерять)
# чтобы компьютер понимал программу написанную человеком она должна переводиться в машинный код
# машинный код говорит процессору где какие транзисторы включить
# потом были придуманы языки програмирования, соотвестенно чтобы компьютер понимал абстракцию которую пишет человек были созданы программы компилятор и интерпретатор

# компилятор та программа которая переведет код в машинный код и вернет исполняемый файл в котором лежат инструкции для компьютера
# интерпретатор тоже программа которая переводит в машинный код по строчкам: переводит выполняет идет к следующей строчке

# опять таки разница в том что в компиляции мы заранее генерируем машинный код для всего исходного и получаем файл который можно запускать
# а тут ничего не генерируем а передаем исхоный код в интерпрератор а тот перводит и выполняет код построчно
# есть свои плюсы и минусы, типо теряется производительность но при этом на любой системе можно запситить

# в джаве например есть byte code это еще не машинный но и не исходный, выполняется на JVM и нужен чтобы джава могла запускаться на всех системах и платформах

# =====================================================

# ПРО ТИПИЗАЦИЮ В ПИТОНЕ
# языки програмирование по типизациии можно поделить на два вида статический и динамический
# а типизацию в них на сильную и слабую

# языки с динамической типизацией чаще всего интерпритутируемые и в которых тип данных определется во время выполнения программы
# языки со статической типизацией чаще всего комплируемые где типы данных определяются до запсука программы
# в языках со статической типизацией менять тип данных переменной переназначением нельзя а в языках с динамической можно

# при сильной или строгой типизацией мы не можем перемешивать типы данных, типо применять действия строго для строк к числам
# а при слабой типизации интерпретатор сам определит какой тип данных лучше использовать
# например в js слабая и там если мы сделаем такую операцию console.log(10 + 'яблоко') поличм 10яблоко, пайтон бросил бы ошибку

# и последние два подвида явная и неявная типизация, при явной в коде всегда нужно указывать какой тип у элемента а при неявной язык сам понимает какой это тип данных

# по итогу пайтон это язык динамической сильной неявной типизации

# =====================================================

# Зачем нужно if name == __main__:
# важно понимать что когда мы импортируем модуль то мы выполняем весь код котороый там написан как будто мы его щапсутили
# так как как каждый модуль в питоне имеет имя(не то которе у файла а именно имя для питона)
# тот модуль с которого запущена программа он получает имя __main__
# тем файлам которые импортируется присваеватся имя модуля

# по сути эта конструкция обозначет что если этот модуль не импортирован а именно запущен и если запущен то выполнить определнный код

# то есть она нужна именно при работе в большом проекте с большим кол-во модулей файлов и импоротов и тд
# чтобы например писать туда тесты быстрые (отладка)

# по мтогу удобство в том что если мы импортируем модуль а в нем написаны какие то проверки это испортит вывод и эта проверка как раз таки помогает это исправить
# а второе удобство это то что все выводы и проверки собраны в ожном месте и нам не нужно их искать по всему коду

# =====================================================

# РАБОТА ОПЕРАТИВНОЙ ПАМЯТИ КОМПЬЮТЕРА (в целом ничего нового, просто чтобы не потерять)

# когда исполняем программу все вычесления просиходят в процессоре
# оперативная память нужна чтобы хранить там значение которые ЦП может вызвать

# Данные в оперативной памяти хранятся в байтах
# пример: мой компьютер имеет 16 гб оперативной памяти это 16000000000 байт
# каждый байт состоит из 8 бит который может принимать состояние либо 1 либо 0
# человечество придумало как с помощью тоьлко 0 и единиц отобразить огромное кол-во вещей

# с помощью 1 байта информации можно отобразить 256 чисел (так как каждая ячейка может хранить в себе два значения 2**8)
# с помощью таблицы ASCII можно отобразить и буквы

# процессоры устроены так что воспринимают информацию по 8 бит то есть по 1 байту
# каджый байт в памяти чтобы мы получили доступ к нему дожен иметь адрес
# позиции пронумерованы от 0 до количества количества байт - 1
# каждая ячейка хранит 1 байт
# адресы отобраены в шестнадцеричной системе, например в оперативной памяти с 1мб места первый адрес: 0x000000 последний: 0xFFFFFF

# некоторые типы данных, что логично, занимают больше места чем один байт (int: 4 байта, char: 1 байт)


# =====================================================

# КРАТКО про модули

# модуль по сути такой же питоновский файл в которм хранится набор классов переменных и тд и когда мы импортируем модуль
# мы можем импортировать его весь то есть весь файл а можем например какой то класс
from collections import deque
from collections import *

# то есть мы можем и сами создать какой то модуль создав файл cat например как в примере с ооп и оттуда брать какие то данные

# ДЕКОРАТОРЫ
# Декоратор - штука которая помогает ищменить поведение функции не изменяя ее год

# Пример декоратора:

# ДВА ВАЖНЫХ МОМЕНТА: ФУНКЦИЯ - объект, внутрення функция может иметь доступ к аргументам внешней

def logger(func): # декоратор принимает на вход функцию которую будем менять
    def wrap(*args): # обертка это то чем станет наша функция и они принимает на вход все аргументы которая имеет функция которую изменям
        print(f"{func.__name__} started") # как то поменяли поведение
        res = func(*args) # вызвали функцию соотвестено полуичв результат
        print(f"{func.__name__} finished")
    
        return res
    
    return wrap # важно вернуть не результат а именно саму функцию так как потом следует операция переназначения изначальной функции и она должна остаться функцией а не результатом

# почему именно объект возвращаем:
# по сути ведь когда мы пишем @logger, интерпретатор делает следующую операцию:
# summ = logger(summ) и если мы вернем объект то summ и останется функцией но уже видоизменненной а если вызовем wrap то это будет результат

# то есть суть декоратора в том чтобы ПОДМЕНИТЬ поданную функцию на обложку и вернуть эту обложку

# вот на примере:

@logger # по сути когда доходим до этой строчки summ = logger(summ)
def summ(a, b):
    return a + b

print(summ(2, 3))
# summ started
# summ finished
# 5

# ДЕКОРАТОР С ПАРАМЕТРАМИ
# по сути ничего сложного добавляем просто еще один уровень вложенности (можно увидеть в тг ботах)
def typed(type_): # нижнее подчеркивание для того чтобы аргумент не мешался с type методотм
    def real_decor(func):
        def wrap(*args):
            for arg in args:
                if not isinstance(arg, type_):
                    raise ValueError(f"Тип должен быть {type_}")
            
            return func(*args)
        return wrap
    return real_decor
@typed(int) # по сути что происходит тут это вызывается фукнцийя typed она возвразает real_decor и уже real_decor декорирует поданную функциую calculate = typed(int)(calculate) - вот так по сути под копотом
def calculate(a, b, c):
    return a + b + c

# БОЛЬШОЙ ПРО ООП
# ООП - объектно ориентированное програмирование, стиль програмирование в котором все является объектом
# каждый объект имеет свои свойства и методы
# как например: кот - объект, умеет: мяукать, бегать, свйоства: серый, 4 ноги

class Cat: # класс не объект класс это как тип данных, как int это общий тип, а 2 3 4 5 это конкретные объекты
    def __init__(self, color, legs):
        self.color = color
        self.legs = legs

    def meow(self):
        print("meow")

tom = Cat("gray", 4) # конкретный представитель
tom.meow()

# про self:
# self - ссылка на объект с которым работаем
# если вызываем метод от объекта как я сделал сверху то self не явно передается пайтоном под копотом
# то есть tom.meow() = Cat.meow(tom) то же самое, понятнее, когда язык видит строчку tom.meow() узнает у тома че за тип, получает такой то такой то класс и определенный метод и в этот метод уже передает ссылку на объект от которого вызываем этот метод 


# ДАНДЕР МЕТОДЫ - позволяют более гибко работать со встроенными вещами в классе
# свойства обозначаем в дандер методе __init__(иницлизация класса)
# если не создали init в классе то нельзя передать аргументы

# repr - дандер метод для програмистов который возвращает строку по которой видно и можно воссоздать состояние объекта (надо указывать состояние объекта Banknote(50))
# str - для людей возврващает строку
# eq - по умолчанию сравнивает адрес в памят в реадизации лучше сразу проверить тип чтобы не сравнивать апесльин с банкнотой 
# если методы сравнения не реализованы то падает ошибка, везде там тожно нужно проверять нужный тип 
# contains - для реализации проверки IN
# если не реализован стр или репр то будет возвращен адрес в памяти 
# по умолчанию проверка bool всегда вернет true, для изменения поведения прописывается дандер метод bool
# len тоже вернет ошибку если не реализовать len дандер метод
# дандер метод call делает объект класса callable, по сути в него можно записать любое поведение, в моем примере это сколько суммарно в кошельке денег
# iter - возвращает объект итерратор, тот кто реализует итер = итерабл
# next - должен вернуть след объект ищ контейнера а тот кто ЕГО реадизует = Итератор
class Banknote:
    def __init__(self, value: int):
        self.value = value
    
    def __repr__(self): # типо для програмистов
        return f"Banknote({self.value})"
    
    def __str__(self): # для людей
        return f"Банкнота номиналом в {self.value} рублей"
    
    def __eq__(self, other): # без реализации этого метода питон будет сравнивать ссылки в памяти и выведет True только если это один и тот же объект
        return self.value == other.value
    
    def __lt__(self, other):
        return self.value < other.value 
    
    def __gt__(self, other):
        return self.value > other.value 
    
    def __le__(self, other):
        return self.value <= other.value

    def __ge__(self, other):
        return self.value >= other.value
    
class Wallet:
    def __init__(self, *banknotes:Banknote):
        self.container = []
        self.container.append(banknotes)
        self.index = 0
        
    def __repr__(self) -> str:
        print(f"Wallet({self.container})")

    def __contains__(self, item):
        return item in self.container
    
    def __bool__(self):
        return self.container
    
    def __len__(self):
        return len(self.container)
    
    def __call__(self):
        return f"{sum(e.value for e in self.container)} рублей"

    def __iter__(self): # возвращает итерратор
        return Iterator(self.container)

    
class Iterator:
    def __init__(self, container):
        self.container = container
        self.index = 0

    def __next__(self): # если класс реализует этот метод то он итератор но не итерабл
        while self.index <= self.index < len(self.container):
            value = self.container[self.index]
            # тут просто реализиация метода next чтобы сделать этот класс итератором
            self.index += 1
            
            return value
        raise StopIteration # если выходит за пределы длины объекта бросаем исключение

# iterable некоторый объект который возвращает итератор 
# итерратор это тот объект который при вызове метода next возвращает один из своих элементов
if __name__ == "__main__":
    fifty = Banknote(50) 
    hundred = Banknote(100)
    print(f"{fifty!r}") # Banknote(50)
    print(fifty) # Банкнота номиналом в 50 рублей

    wallet = Wallet(fifty, hundred)
    print(hundred in wallet) # True

    print(wallet) # Wallet([Banknote(50), Banknote(100)])

# НАСЛЕДОВАНИЕ

# ИНКАПСУЛЯЦИЯ 
# подразумивает то что все данные и все методы собраны в одну "капсулу", то есть класс и предоставляем публичный интерфейс
# в питоне не подразумивает сокрытие данных!

# _ - (protected) ЗНАК того что свойство или метод не предназначем для прямого использования. Работа объекта не гаранируется при их использовании
# то есть использовать и менять эти свойства все равно можно в питоне не как в других языках, но знак что лучше этого не делать

# __ - (private) под копотом приобразуется в object._Class__attribute
# имеется в виду что если мы создали свойство или метод с двойным подчеркиванием то под копотом пайтон заменят его имя в такой формат: object._Class__attribute 

# вообщем и целом тк пайтон максимально гибкий язык и в нем можно почти все поменять и посмотреть суть инкапсуляции тут отличается от других языков
# и заключается не в том чтобы полностью скрыть какой то метод или свойство а лишь сказать о том что их лучше не трогать

# РАЗНИЦА _ и __ в том что на _ интерпретатор не реагирует и это только для человека, что лучше не надо это трогатоь
# а __ изменятся интерпретатором и преобразуется в object._Class__attribute










# написать про: дандер методы,  функции, множества, рекурсия(именно как под копотом), наследование, сеттеры и геттеры